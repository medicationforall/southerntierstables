<?php

/**
 *   Medication For All Framework source file Account,
 *   Copyright (C) 2009-2011  James M Adams
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU Lesser General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU Lesser General Public License for more details.
 *
 *   You should have received a copy of the GNU Lesser General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *@package framework
 */

/** 
 *Account variables associated to a logged in user.
 *
 *@author James M Adams <james@medicationforall.com>
 *@version 0.2.5
 *@see Page
 *@package framework
 */

class Account
{
//data
/**
 *   Users logged in name.
 *@access private
 *@var string
 */
	private $name;

/**
 *   Salt used to obfuscate all users passwords.
 *@access private
 *@var string
 */
	private $salt;

/**
 *   User logged in toggle.
 *@access private
 *@var boolean
 */
	private $login;

/**
 *   Edit features toggle.
 *@access private
 *@var boolean
 */
	private $edit;

/**
 *   Edit the pages meta data toggle.
 *@access private
 *@var boolean
 */
	private $editMeta;

/**
 *   User access level. 
 *   Used as a flag for what features the logged in user can access.
 *@access private
 *@var string
 */
	private $mode = 'none';

/**
 *   EULA End User License Agreement.
 *@access private
 *@var string
 */
	private $eula = '';

/**
 *   Eula accept flag.
 *@access private
 *@var boolean
 */
//private $eulaAccept = false;

/**
 *   Minimum password length.
 *@access private
 *@var int
 */
	private $minLength;

/**
 *   Require uppercase character flag.
 *@access private
 *@var boolean
 */
	private $requireUpper = false;

/**
 *   Require Numeric character flag.
 *@access private
 *@var boolean
 */
	private $requireNumber = false;

/**
 *   Require punctuation flag.
 *@access private
 *@var boolean
 */
	private $requirePunctuation = false;

/**
 *   Failed login attempts counter.
 *@access private
 *@var int
 */
	private $loginFail = 0;

/**
 *   Max failed login attempts.
 *@access private
 *@var int
 */
	private $loginFailMax = 4;

/**
 *   Md5 token created randomly upon page load.
 *@access private
 *@var string
 */
	private $token = null;

	private $ajaxToken = null;

/**
 *   Preferred Encryption type used for storing user passwords.
 *@access private
 *@var int
 */
	private $encryption = 'phpass';

/**
 *   Error message generated by checkPassword.
 *@access private
 *@var int
 */
	private $message = '';

/**
 *md5 of the username and system wide salt.
 *@access private
 *@var string
 */
	private $owner = null;

	private $bias = 0;

	private $spamThreshold = 2;


//methods
/**
 *   Gets the logged in user name.
 *@return string The logged in users name. May return null
 */
	function getName() {
		return $this->name;
	}

/**
 *   Sets the logged in user name.
 *@param string $n Sets logged in users name.
 */
	function setName($n) {
		$this->name =$n;
		$this->owner = md5($this->name.$this->salt);
	}


/**
 *   Placeholder function which calls setSalt.
 *@param string $h Salt value.
 *@see setSalt 
 */
	function setHash($h) {
		$this->setSalt($h);
	}

/**
 *  Placeholder function which calls getSalt.
 *@return string
 *@see getSalt
 */
	function getHash() {
		return $this->getSalt();
	}

/**
 *   Sets the encryption salt.
 *@param string $h Sets salt encryption value.
 */
	function setSalt($h) {
		$this->salt = $h;
	}

/**
 *   Gets the encryption salt. Throws an exception if no salt is set.
 *@return string
 */
	function getSalt() {
		$returner = $this->salt;

		if(empty($this->salt)) {
			throw new Exception('Account salt is empty, set a global salt to use this component.');
		}
		return $returner;
	}

/**
 *   Get user login boolean.
 *@return boolean Is user logged in?
 */
	function isLogin() {
		return $this->login;
	}

/**
 *   Set user login boolean.
 *@param boolean $l Set user log in status.
 */
	function setLogin($l) {
		/*This bit of code in here because of http://shiflett.org/articles/session-fixation
		And should alleviate this kind of attack. Whenever a user logs in or logs out, 
                a new session id is created, but the session data is kept, 
                so other session variables will be left undisturbed.
		If session variables were to be stored by database this code would have to be changed.
		*/
		$save_session = $_SESSION;

		session_regenerate_id();

		$_SESSION = $save_session;

		$this->login = $l;
	}

/**
 *   Gets edit boolean.
 *@return boolean Is edit features turned on?
 */
	function isEdit() {
		return $this->edit;
	}

/**
 *   Sets edit boolean.
 *@param boolean $e Set edit features flag.
 */
	function setEdit($e) {
		$this->edit = $e;
	}

/**
 *   Gets edit meta boolean.
 *@return boolean Is edit meta feature turned on?
 */
	function isEditMeta() {
		return $this->editMeta;
	}

/**
 *   Sets edit meta boolean.
 *@param boolean $e Set edit meta Flag.
 */
	function setEditMeta($e) {
		$this->editMeta = $e;
	}

/**
 *   Gets user mode.
 *@return string Logged in users mode level ie permission.
 */
	function getMode() {
		return $this->mode;
	}

/**
 *   Sets user mode.
 *   The allowed user modes is enforced in the database, 
 *   the reasoning behind why it's not being error checked here (yet).
 *@param string $m Set the logged in users mode level ie permission.
 */
	function setMode($m) {
		$this->mode = $m;
	}

/**
 *Logs the account out of everything.
 */
	function logout() {
		$this->setName(null);
		$this->setLogin(false);
		$this->setMode('none');
		$this->setEdit(false);
		$this->setEditMeta(false);
		$this->owner = null;
	}

/**
 *   Sets the end user license agreement text.
 *@param string $l License Text.
 */
	function setEULA($l) {
		$this->eula = $l;
	}

/**
 *   Gets the end user license agreement text.
 *@return string
 */
	function getEULA() {
		return $this->eula;
	}

/**
 *   Sets the minimum password length.
 *@param int $l
 */
	function setMinLength($l) {
		$this->minLength = $l;
	}

/**
 *   Gets the minimum password length.
 *@return int
 */
	function getMinLength() {
		return $this->minLength;
	}

/**
 *   Gets uppercase letter password requirement flag.
 *@return boolean
 */
	function isRequireUpper() {
		return $this->requireUpper;
	}

/**
 *   Sets uppercase letter password requirement flag.
 *@param boolean $u
 */
	function setRequireUpper($u) {
		$this->requireUpper = $u;
	}

/**
 *   Gets numeric character password requirement flag.
 *@return boolean
 */
	function isRequireNumber() {
		return $this->requireNumber;
	}

/**
 *   Sets numeric character password requirement flag.
 *@param boolean $n
 */
	function setRequireNumber($n) {
		$this->requireNumber = $n;
	}

/**
 *   Gets symbol character password requirement flag.
 *@return boolean Symbol requirement flag.
 */
	function isRequirePunctuation() {
		return $this->requirePunctuation;
	}

/**
 *   Sets symbol character password requirement flag.
 *@param boolean $p
 */
	function setRequirePunctuation($p) {
		$this->requirePunctuation = $p;
	}

/**
 *   Checks the current permission level against the permission level passed and 
 *   returns boolean whether the feature can be accessed or not.
 *@param string $c Access level, proper values is: 'none','user','edit','admin'.
 *@return boolean
 */
	function access($c) {
		$returner = false;

		$modes = Core::getModes();

		if($modes[$this->mode] >= $modes[$c])
		{
			$returner = true;
		}
		return $returner;		
	}

	
/**
 *   Increment login fail. If the user did not successfully login on attempt.
 */
	function loginFailAdd() {
		$this->loginFail++;
 	}

/**
 *   For resetting login system state for selenium tests.
*/
	function loginFailReset() {
		$this->loginFail = 0;
	}

/**
 *   Gets the number of failed login attempts for the current session.
 *@return int
 */
	function getLoginFail() {
 		return $this->loginFail;
 	}

/**
 *   Sets the max number of failed login attempts.
 *@param int $m
 */
	function setLoginFailMax($m) {
 		$this->loginFailMax = $m;
 	}

/**
 *   Gets the max number of failed login attempts
 *@return int
 */
	function getLoginFailMax() {
		return $this->loginFailMax;
	}

/**
 *   Gets the randomly generated page token.
 *@return string
 */
	function getToken() {
		return $this->token;
	}

/**
 *   Sets the page token which is typically done on page load *after process() is run*,
 *   but before show() is run.
 *http://www.codewalkers.com/c/a/Miscellaneous/Stopping-CSRF-Attacks-in-Your-PHP-Applications/1/
 */
	function setToken() {
		$this->token = md5(uniqid(rand(), true));
	}

/**
 *
 */
	function setAjaxToken() {

		$post = '';

		foreach($_POST as  $key => $value) {
			if(!empty($post)){
				$post .= '&';
			}

			if(strcmp($key,'tokenFlag')!=0){
				$post .= $key.'='.$value;
			}
		}

		$this->ajaxToken = md5(uniqid(rand(), true).$post);

		//print $post;
		//print $this->ajaxToken;
	}
/**
 *
 */
	function getAjaxToken() {
		return $this->ajaxToken;
	}

/**
 *   Generates a password hash (one way) based on the chosen encryption type.
 *@param string $password Password un-hashed.
 *@param String userName to be tied to the password hash. 
 *@return string hashed password.
 */
	function makePassword($password, $user="") {
		$returner;

		if(!empty($password)) {
			if(strcmp($this->encryption, 'phpass')==0) {
				$phpPass = new PasswordHash(8, false);
				$returner = $phpPass->HashPassword($user.$password.$this->salt);
			}
		}
		return $returner;
	}

/**
 *   When running checkPassword() the latest error message is stored and has to be recalled.
 *@return string
 */
	function getMessage() {
		return $this->message;
	}


/**
 *   For password creation this function checks that the users password passes all chosen criteria. 
 *   This code is used for ComponentCreateUser and ComponentChangePassword. 
 *   It explicitly is not used for ComponentLogin.
 *@param string $newPass
 *@return boolean
 */
	function checkPassword($newPass)
	{
		$pass = true;
		$subMessage = '';
		$minLength = $this->getMinLength();

		if($minLength != null) {
			if(strlen($newPass) >= $minLength)
			{
			}
			else {
				$subMessage = '<div class="error">Password must be greater than '.($minLength-1). ' characters</div>';
				$pass=false;
			}
		}

		if($this->isRequireUpper()) {
			$upperPass = false;

			$count = strlen($newPass);
			for($i =0 ; $i<$count;$i++) {
				$char = substr($newPass, $i, 1);

				if(ctype_upper((string)$char)) {
					$upperPass=true;
				}								
			}

			if($upperPass == false) {
				$subMessage .= '<div class="error">Password must contain at least one uppercase letter.</div>';
				$pass=false;
			}
		}

		if($this->isRequireNumber()) {
			$numberPass = false;

			$count = strlen($newPass);
			for($i =0 ; $i<$count;$i++) {
				$char = substr($newPass, $i, 1);

				if(ctype_digit((string)$char)) {
					$numberPass=true;
				}								
			}

			if($numberPass == false) {
				$subMessage .= '<div class="error">Password must contain at least one number.</div>';
				$pass=false;
			}
		}

		if($this->isRequirePunctuation()) {
			$punctPass = false;

			$count = strlen($newPass);
			for($i =0 ; $i<$count;$i++) {
				$char = substr($newPass, $i, 1);

				if(ctype_punct((string)$char)) {
					$punctPass=true;
				}								
			}

			if($punctPass == false) {
				$subMessage .= '<div class="error">Password must contain at least one character that\'s not a number or letter.</div>';
				$pass=false;
			}
		}
		$this->message = $subMessage;
		return $pass;
	}

/**
 *Get the account owner hash.
 *@return string Combined md5 hash of username and system salt.
 */
	function getOwner() {
		return $this->owner;
	}

/**
 *
 */
	function getBias() {
		return $this->bias;
	}


/**
 *
 */
	function setBias($b) {
		$this->bias = $b;
	}

/**
 *
 */
	function increaseBias($b) {
		$this->bias += $b;
	}

/**
 *
 */
	function isSpammer(){
		//echo 'bias is: '.$this->bias.' threshold is: '.$this->spamThreshold;
		if($this->bias < $this->spamThreshold){
			return false;
		}else {
			return true;
		}
	}


	/**
	 *Custom Awesome Debug Content.
	 */
	function adContent()
	{
		echo '<br /><br /><span class="lightTitle">Account Content:</span>';
		echo '<br /> '.'<span class="lightTitle">Logged in:</span> ';
		if($this->login)
		{echo 'true';}
		else
		{echo 'false';}
		echo '<br /> '.'<span class="lightTitle">Logged in Name:</span> '.$this->name;
		echo '<br /> '.'<span class="lightTitle">Permission:</span> '.$this->mode;
		echo '<br /> '.'<span class="lightTitle">Salt:</span> '.$this->salt;
		echo '<br /> '.'<span class="lightTitle">hash:</span> '.$this->encryption;
		echo '<br /> '.'<span class="lightTitle">Password min-length:</span> '.$this->minLength;
		echo '<br /> '.'<span class="lightTitle">Password Req Upper:</span> ';
		if($this->requireUpper)
		{echo 'true';}
		else
		{echo 'false';}
		echo '<br /> '.'<span class="lightTitle">Password Req Number:</span> ';
		if($this->requireNumber)
		{echo 'true';}
		else
		{echo 'false';}
		echo '<br /> '.'<span class="lightTitle">Password Req Punctuation:</span> ';
		if($this->requirePunctuation)
		{echo 'true';}
		else
		{echo 'false';}
		echo '<br /> '.'<span class="lightTitle">Login Fail Attempts:</span> '.$this->loginFail;
		echo '<br /> '.'<span class="lightTitle">Login Fail Max Attempts:</span> '.$this->loginFailMax;
		echo '<br /> '.'<span class="lightTitle">Edit Flag:</span> ';
		if($this->edit)
		{echo 'true';}
		else
		{echo 'false';}
		echo '<br /> '.'<span class="lightTitle">Meta Flag:</span> ';
		if($this->editMeta)
		{echo 'true';}
		else
		{echo 'false';}
		echo '<br /> '.'<span class="lightTitle">Security Token:</span> '.$this->token;

		echo '<br /> '.'<span class="lightTitle">EULA:</span> '.$this->eula;
		echo '<br /> '.'<span class="lightTitle">Message:</span> '.$this->message;
		echo '<br /> '.'<span class="lightTitle">Owner:</span> '.$this->owner;

	}
}
?>
